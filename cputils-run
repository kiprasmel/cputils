#!/usr/bin/env bash
# the good stuff

#
# TODO:
# we need to simplify the explanation (of "-a" vs "--")
#
# it's possible: use "-a" as the first example
# and then mention that "--" is the same but must be used at least once
# at the end of the execution chain)
#

CFGDIR="$HOME/.config/cputils"
source "$CFGDIR/cputils.config.bash"

#
# the reason we switched from ".in" to ".txt"
# is because the editor(e.g. neovim + coc-clangd)
# would recognize the filetype of ".cpp.in" to be "cpp"
# and thus the linter & other annyoing stuff would jump in
# even though the file was just a regular input file,
# thus we've switched to just regular ".txt"
#
# still configurable tho:D
#
[ -z "$INPUT_CACHE_FILE_EXTENSION" ] && INPUT_CACHE_FILE_EXTENSION="txt"

USAGE="\
usage:

cputils-run FILENAME.cpp [- [INPUT_FILE]] [-a \"EXTRA_COMPILER_ARGS\"]... [-- EXTRA_COMPILER_ARGS]

  where
    FILENAME.cpp                = source file you want to run

    -                           = reuse previous input
                                  instead of reading from clipboard

    INPUT_FILE                  = input file to take input from.
                                  default: FILENAME.cpp.$INPUT_CACHE_FILE_EXTENSION
    
    -a \"EXTRA_COMPILER_ARGS\"    = pass arguments to the compiler (quotes necessary),
                                  can be used multiple times.

                                  hint: set custom #define's from here
                                  or override default settings etc.
                                  very useful for shell aliases / functions
                                  (see the examples below)

    -- EXTRA_COMPILER_ARGS      = same as \`-a\`, just for extra convenience
                                  (no quotes needed, must be used at most once, since
                                  \`--\` will stop argument parsing and will forward
                                  everything to the compiler)


  examples:
    simple:
      cputils-run a.cpp               # reads input from clipboard
      cputils-run a.cpp -             # reads input from file \"a.cpp.$INPUT_CACHE_FILE_EXTENSION\"
      cputils-run a.cpp - in          # reads input from file \"in\"

    with args to the compiler:
      cputils-run a.cpp      -- -DDEBUG -std=c++98 -Wextra
      cputils-run a.cpp -    -- -DDEBUG -std=c++17 -Wextra -Wpedantic
      cputils-run a.cpp - in -- -DEVAL  -std=c++20 -O2

    using alias functions:
      .bashrc / .zshrc etc.:

      xd() { cputils-run -a \"-DDEBUG\" \$* }

    simple (using aliases):
      xd a.cpp               # reads input from clipboard
      xd a.cpp -             # reads input from file \"a.cpp.$INPUT_CACHE_FILE_EXTENSION\"
      xd a.cpp - in          # reads input from file \"in\"

    with args to the compiler (using aliases):
      xd a.cpp      --        -std=c++98 -Wextra
      xd a.cpp -    --        -std=c++17 -Wextra -Wpedantic
      xd a.cpp - in -- -DEVAL -std=c++20 -O2

"

# parse arguments

[ -z "$1" ] && {
	printf "$USAGE"
	exit 1
}

trim_extension() {
	printf "${1%.*}"
}

EXTRA_FROM_ALIAS=""

while (( $# )); do
	case "$1" in
		-)
			WHICH_INPUT_USED="FILE_CACHE"
			shift
			;;
		--)
			shift
			break
			# stop parsing and forward rest of arguments
			# to the compiler
			;;
		-a)
			shift
			EXTRA_FROM_ALIAS="$EXTRA_FROM_ALIAS $1"
			shift
			;;
		*)
			if [ -z "$INPUT_FILE" ]; then
				INPUT_FILE="$1"

				[[ "$INPUT_FILE" =~ \.$INPUT_CACHE_FILE_EXTENSION$ ]] && {
					# remove the configured extension suffix -
					# likely a mistake by the user,
					# since we're adding the suffix ourselves

					INPUT_FILE="$(trim_extension "$INPUT_FILE")"
				}

				shift
			elif [ ! -z "$WHICH_INPUT_USED" ]; then
				WHICH_INPUT_USED="FILE_CUSTOM"
				CUSTOM_INPUT_FILE="$1"
				shift
			else
				printf "$USAGE"
				shift
				exit 1
			fi
			;;
	esac
done

[ -z "$WHICH_INPUT_USED" ] && WHICH_INPUT_USED="CLIPBOARD"

# echo "INPUT_FILE $INPUT_FILE; WHICH_INPUT_USED $WHICH_INPUT_USED; CUSTOM_INPUT_FILE $CUSTOM_INPUT_FILE;"

# remove extension & add ".out" suffix (easier to .gitignore etc)
# https://stackoverflow.com/a/36341390/9285308
#
# the path and filename need to be extracted
# to handle both cases:
# a) user provides path to the filename
# b) user provides filename (path is current working dir)
# with this, it works in both cases
#
INPUT_FILE_PATH="$(dirname "$INPUT_FILE")"
INPUT_FILE_FILENAME="$(basename "$INPUT_FILE")"
INPUT_FILE_FILENAME_EXTLESS="$(trim_extension "$INPUT_FILE_FILENAME")"
OUTPUT_FILE="$INPUT_FILE_PATH/$INPUT_FILE_FILENAME_EXTLESS.out"

INPUT_CACHE_FILE="$INPUT_FILE.$INPUT_CACHE_FILE_EXTENSION"
touch "$INPUT_CACHE_FILE"

# determine INPUT and INPUT_INFO

if [ "$WHICH_INPUT_USED" = "CLIPBOARD" ]; then
	INPUT_INFO="CLIPBOARD"
	INPUT="$(xclip -selection clipboard -o || xclip -selection primary -o)"

	# prepend the input from clipboard into the cache file
	mv "$INPUT_CACHE_FILE" "$INPUT_CACHE_FILE.bp"
	printf "$INPUT\n\n\n" >> "$INPUT_CACHE_FILE"
	cat "$INPUT_CACHE_FILE.bp" >> "$INPUT_CACHE_FILE"
	rm "$INPUT_CACHE_FILE.bp"

elif [ "$WHICH_INPUT_USED" = "FILE_CACHE" ]; then
	INPUT_INFO="FILE ($INPUT_CACHE_FILE)"
	INPUT="$(cat $INPUT_CACHE_FILE)"

elif [ "$WHICH_INPUT_USED" = "FILE_CUSTOM" ]; then
	INPUT_INFO="FILE ($CUSTOM_INPUT_FILE)"
	INPUT="$(cat $CUSTOM_INPUT_FILE)"

else
	printf "\
cputils-run error: parsing arguments went wrong ¯\\_(:c)_/¯

create an issue here:
https://github.com/kiprasmel/cputils

"
	exit 1
fi

# determine if it's safe to skip compilation 

INPUT_HASH_FILE="$INPUT_FILE_FILENAME.hash"
NEW_SOURCE_FILE_HASH="$(create_hash "$INPUT_FILE")"
CREATE_HASH_RETURN_STATUS=$?

if [ "$CREATE_HASH_RETURN_STATUS" -ne 0 ]; then
	HASHING_ENABLED=0
else
	HASHING_ENABLED=1

	touch "$INPUT_HASH_FILE"
	OLD_HASH="$(cat "$INPUT_HASH_FILE")"
fi

#
# the outcome depends on other side effects - extra args to the compiler
# come to mind. We might've missed something -- take care
# 
# the separator '@' is picked arbitrarily; it's only important that it's there
#
NEW_HASH="$NEW_SOURCE_FILE_HASH @ -a \"$EXTRA_FROM_ALIAS\" @ \$* \"$*\""

#
# the user by default will have the 'create_hash' function disabled,
# thus $NEW_HASH will be an empty string, which is not allowed,
# thus we never skip compilation
#
# otherwise, we do not check the $OLD_HASH, since it is allowed
# for it to be empty (always happens at the very first run)
# 
#
if [ "$OLD_HASH" = "$NEW_HASH" ] && [ "$HASHING_ENABLED" -eq 1 ]; then
	SAFE_TO_SKIP_COMPILATION=1
else
	SAFE_TO_SKIP_COMPILATION=0
fi

# run based on time cmd (best if GNU /usr/bin/time is available)
if command -v /usr/bin/env time &>/dev/null; then
	runner() {
		TIME_CMD="/usr/bin/env time"
		TIME_CMD_ARGS="-f \nmem  %M KB\nreal %es\nuser %Us \nsys  %Ss\n"

		printf "$INPUT\n" | ($TIME_CMD "$TIME_CMD_ARGS" "$OUTPUT_FILE")
	}
else
	runner() {
		printf "$INPUT\n" | (time                       "$OUTPUT_FILE")
	}
fi

# go go go

printf "BEGIN INPUT\n$INPUT\nEND INPUT\n"
printf "$INPUT_INFO\n\n"


if [ "$SAFE_TO_SKIP_COMPILATION" -eq 1 ]; then
	runner

	printf "NO_RECOMPILE\n"
else
	# do NOT quote $EXTRA_FROM_ALIAS nor $*
	# because this allows them to expand
	# and act as multiple different arguments
	# as opposed to a single one

	g++ -std=c++17 -g -Wall -o "$OUTPUT_FILE" "$INPUT_FILE"  $EXTRA_FROM_ALIAS  $*  && \
	if [ "$HASHING_ENABLED" -eq 1 ]; then printf "$NEW_HASH" > "$INPUT_HASH_FILE"; fi && \
	runner
fi

printf "\n"

